# Dridex Loader (v2020)

### MD5 : df1b0f2d8e1c9ff27a9b0eb50d0967ef

This binary is part of the 24 hours CTF "$tealer CTF" (https://stealer-ctf.cyberdefenders.org/), for the one we finnished at the first place.

The goal was to reverse the provided sample and answer some basic questions about it's inner-working.

## API Hashing

A classic API hashing technique is used to hide the Windows API employed by dridex. 

The API hash algorithm is split in two part: a first one responsible for retreiving the DLL name from wich the target API must be resolved, and the API name itself.

The algorithm can be sum up as the following:
```C
api_hash == (func_crc32((int)ptr_api_str, api_str_len) ^ 0x38BA5C7B)
```

The hash is made of a simple CRC32 that is xored with a constant value.

The hashdb IDA Plugin was used to resolved the API hash and the DLL names for this analysis. After a bit of work, the 300+ api were resolved.

```C
.text:00623884 push    0x0336E58DC ; HttpSendRequestsW
.text:00623889 push    0x0D27F045A ; WININET.DLL
.text:0062388E call    func_apiHashing
```

## String Encryption

We can spot the algorithm and recognize some RC4 constant and routine:

```C
for ( i = 0; i < 0x100; ++i ) {
      v12 = *(_BYTE *)(i % (__int64)arg_start + a1);
      S[i] = i;
      S[i + 256] = v12;
}
LOBYTE(j_bis) = 0;
for ( j = 0; j < 128; ++j ) {
      i_bis = S[2 * j];
      v16 = (unsigned __int8)(j_bis + i_bis + S[2 * j + 256]);
      v17 = S[2 * j + 257];
      S[2 * j] = S[v16];
      S[v16] = i_bis;
      S_i = S[2 * j + 1];
      j_bis = (unsigned __int8)(v16 + S_i + v17);
      S[2 * j + 1] = S[j_bis];
      S[j_bis] = S_i;
}
```

The strings are encrypted by chunks in the .rdata section.

The first 0x28 bytes of thoses chunks is the key to decrypt the following bytes.

Each chunk uses a different key.

```C
int key_size = 0x28;
func_RC4_decrypt(ptr_out, &chunk, key_size, v34, v35, 0, 0);
```

Some instance of the used RC4 key in this sample:
```bash
D5 BB C5 3E 12 94 70 92 5A 59 E6 EA 6A A9 E6 C4 8B C4 8D 50 93 D5 1C D4 33 88 41 26 BA E4 A8 15 60 E7 B1 91 48 93 3C DB

77 D5 43 38 93 E1 11 17 E1 EB B3 BE A4 F7 2A 8D D5 EC AA 17 A4 F8 3E B6 28 3D 8B 6E 76 4A 88 59 60 B4 78 E0 85 E7 01 40 
```

With the decrpyted strings, we can spot the botnet ID: "10444".

The interesting decrpyted strings are the followings:
```bash
* chunk 0x628580:
SOFTWARE/TrendMicro/Vizor
\VizorUniclientLibrary.dll
ProductPath

* chunk 0x629500 (configuration):
Starting path: 
ShellFolder
9fRysqcdPgZffBlroqJaZHyCvLvD6BUV;syF7NqCylLS878kcIy9w5XeI8w6uMrqVwowz4h3uWHHlWsr5ELTiXic3wgqbllkcZyNGwPGihI
<autoElevate>true
true
false
<Task xmlns="http://schemas.microsoft.com/windows/2004/02/mit/task" version="1.3"><RegistrationInfo>
</RegistrationInfo><Triggers><LogonTrigger><Enabled>true</Enabled><UserId>
</UserId></LogonTrigger><TimeTrigger><Repetition><Interval>PT30M</Interval><StopAtDurationEnd>false</StopAtDurationEnd></Repetition><StartBoundary>2020-01-01T00:00:00</StartBoundary><Enabled>true</Enabled></TimeTrigger></Triggers><Principals><Principal id="Author"><LogonType>InteractiveToken</LogonType><RunLevel>LeastPrivilege</RunLevel><UserId>
</UserId></Principal></Principals><Settings><MultipleInstancesPolicy>IgnoreNew</MultipleInstancesPolicy><DisallowStartIfOnBatteries>false</DisallowStartIfOnBatteries><StopIfGoingOnBatteries>false</StopIfGoingOnBatteries><AllowHardTerminate>false</AllowHardTerminate><StartWhenAvailable>false</StartWhenAvailable><RunOnlyIfNetworkAvailable>false</RunOnlyIfNetworkAvailable><IdleSettings><StopOnIdleEnd>true</StopOnIdleEnd><RestartOnIdle>false</RestartOnIdle></IdleSettings><AllowStartOnDemand>true</AllowStartOnDemand><Enabled>
</Enabled><Hidden>true</Hidden><RunOnlyIfIdle>false</RunOnlyIfIdle><DisallowStartOnRemoteAppSession>false</DisallowStartOnRemoteAppSession><UseUnifiedSchedulingEngine>false</UseUnifiedSchedulingEngine><WakeToRun>false</WakeToRun><ExecutionTimeLimit>PT0S</ExecutionTimeLimit><Priority>7</Priority></Settings><Actions Context="Author"><Exec><Command>
</Command></Exec></Actions></Task>
<Author>$(@%systemroot%\system32\wininet.dll,-16000)</Author>

* chunk 0x629bc0:
Program Manager
Progman
AdvApi32~PsApi~shlwapi~shell32~WinInet
/run /tn "%ws"
"%ws" /grant:r "%ws":F
\NTUSER.DAT
winsxs
x86_*
amd64_*
*.exe
\Sessions\%d\BaseNamedObjects\
```

## C&C Servers

A list of the C&C servers can be found in the decrypted strings:
```C
192.46.210.220:443
143.244.140.214:808
45.77.0.96:6891
185.56.219.47:8116
```

## Ant-Analysis

This dridex loader used a lot of flow obfuscation techniques through the use of the SEH chain.

To disrupt the execution flow and make the static analysis much harder, the malware add some new entries in the SEH chains, through the "AddVectoredExcetpionHandler" API.

Once the target function is added in the SEH chain, an exception can be raised through the "int 3" interruption instruction.

```C
.text:005FAA99 int     3               ; Trap to Debugger
.text:005FAA9A retn
```

This result in the last function beeing inserted beeing executed silently.

Once this function is executed, the caller returns to the normal execution flow.

## Resources

The annotated .idb can be found in the folder under the name dridex_loader_2020.idb.
