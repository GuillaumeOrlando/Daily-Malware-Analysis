# Emotet Payload

MD5: 49d44a384df772958408224a03e7405b

OriginalFileName: N/A

Size: 64 KB

======================================

Now that we have our unpacked version of Emotet, let's start the real analysis.

Quick disclaimer: as we dumped this from memory, the payload is NOT going to run as a standalone file, so we'll have to do everything from a static analysis point of view, wich is not going to be easy considering the various mechanisms used by Emotet to prevent our analysis.

Opening the file in IDA shows us that we'r not going to be able to read through the file easily.

First, the very few amount of plaintext strings makes me think that some sort of string encryption/obfuscation must be involved here.

# String Decryption
======================================

The string encryption routine is easy to spot in the first few lines of the entrypoint:
```C
v1 = (wchar_t *)func_decipher_strings(dword_40FA10, 0x7D053044);
snwprintf(s, 0x104u, v1, v0);
```

Since the second argument is a sort of 'hash', this must be the key.

And the first one is a pointer to something (the encrypted string) unreadable in the .data section.

The string decrpytion routine can be sumerized to this format:

```C
encrypted_string = (DWORD*)0x40FA10;
key = 0x7D053044
plaintext_string = (wchar_t *)func_decipher_strings(encrypted_string, key);
```

With a different offset/key for each function call (29 xRefs to this function in this sample).

The function looks a bit weird at a first look. I don't know if the compiler was drunk or if the malware author did this on purpose to slow down our analysis.

After renaming everything, the function looks like this:
```C
  size = arg_key ^ *arg_buffer;
  if ( (size & 3) != 0 )
    alloc_size = size - (size & 3) + 4;
  else
    alloc_size = size + 4;
  output_string_buffer = func_allocHeap_wrapper(2 * alloc_size);
  if ( output_string_buffer )
  {
    out_buffer_ptr = (char *)(arg_buffer + 1);
    char_counter = 0;
    v7 = (char *)&arg_buffer[(alloc_size >> 2) + 1];
    decoded_string_len = (unsigned int)(v7 - (char *)(arg_buffer + 1) + 3) >> 2;
    if ( out_buffer_ptr > v7 )
      decoded_string_len = 0;
    if ( decoded_string_len )
    {
      do
      {
        buffer_dword = *(_DWORD *)out_buffer_ptr;
        out_buffer_ptr += 4;
        xor_result = arg_key ^ buffer_dword;
        *output_string_buffer = (unsigned __int8)xor_result;
        output_string_buffer += 4;
        *(output_string_buffer - 3) = BYTE1(xor_result);
        xor_result >>= 16;
        *(output_string_buffer - 2) = (unsigned __int8)xor_result;
        *(output_string_buffer - 1) = BYTE1(xor_result);
        ++char_counter;
      }
      while ( char_counter < decoded_string_len );
    }
    output_string_buffer[size] = 0;
  }
  return output_string_buffer;
```

Which is probably the most over-complicated XOR operation that I've encounter :)

Any way, The idea is that the first basic block is in charge of retreiving the plaintext string's length by xoring the first DWORD of the array (first argument) with the given key (second argument):
```C
size = arg_key ^ *arg_buffer;
```

After that, each DWORD of the array (starting at the position +1, since the first one was already used to get the string's size) is xored with the key:
```C
xor_result = arg_key ^ buffer_dword;
```

Finally, the byte-order of the result is reverse before beeing put in the result buffer:
```C
*output_string_buffer = (unsigned __int8)xor_result;
output_string_buffer += 4;
*(output_string_buffer - 3) = BYTE1(xor_result);
xor_result >>= 16;
*(output_string_buffer - 2) = (unsigned __int8)xor_result;
*(output_string_buffer - 1) = BYTE1(xor_result);
```

Since I will write an IDAPython script that is going to do the job for me, the following function was written in order to be tested (remember, no dynamic analysis here, we can't confirm our finding in a debugger):
```python
def string_decode(buf_dword, key):
    size = buf_dword[0] ^ key
    decoded = b''
    for x in range(1, len(buf_dword)):
        xor_result = buf_dword[x] ^ key
        decoded += struct.pack('<I', xor_result)
    return decoded[:size].decode()
```

We can test it with a random value we grab from the disassembly (not so random, in fact I choosed a string that I know for sure would be readable. In this case, something that is going to be passed to `Loadlibrary`):
```
v0 = func_string_decode(dword_40F320, 0x7D053044);
dword_4126B4 = (int)LoadLibraryW(v0);
```

And the moment of truth:
```python
buf_dword = [ 0x7D05304F, 0x11605837, 0x53370328, 0x7C695C20, 0x1E582339, 0x5C450379, 0x8CE3DE11 ]

key = 0x7D053044

val = string_decode(buf_dword, key)
print(val)
```

Looks like this is working fine !
```
[root@Arch emotet]# python3 string_decryption.py 
shell32.dll
```

We can now start to write an IDAPython script with this algorithm in it to automaticaly resolved the strings used by this Emotet payload.

The skeleton of the script will be the following:
```python
# Guillaume Orlando
# 10/09/2021
# Emotet string decoder (IDAPython3)
import struct
from ida_bytes import *
from idautils import *
from idaapi import *
from idc import *

function_name = 'func_string_decode'

def extract_array_content(address):
        array = []
        for x in range(0, 100):
                dword = ida_bytes.get_dword(address)
                array.append(dword)
                address += 4
                if dword == 0x0:
                        return array
        return array

def decode_str(key, buff_addr):
        buf_dword = extract_array_content(buff_addr)
        size = buf_dword[0] ^ key
        decoded = b''
        for x in range(1, len(buf_dword)):
                xor_result = buf_dword[x] ^ key
                decoded += struct.pack('<I', xor_result)
        return decoded[:size].decode()

for ea in CodeRefsTo(get_name_ea_simple(function_name), 0):
        cfunc = idaapi.decompile(ea)
        args = str(cfunc).split(function_name + '(')[1].split(')')[0]
        key = int(args.split(', ')[1])
        array_addr = int(args.split(', ')[0].split('_')[1], 16)
        print('String decoder call: ' + hex(ea) + ' with key: ' + str(key) + ' and buffer: ' + hex(array_addr))
        decoded = decode_str(key, array_addr)
        print('Result: ' + decoded)
```

Which is going to loop through every cross references of the decoder function, grab it's arguments (key and buffer address) and apply the decryption algorithm on it.

We can confirm that this is working:
```
Emotet String Decoder module loaded
String decoder call: 0x4010f0 with key: 555951482 and buffer: 0x40f000
Result: %s:Zone.Identifier
String decoder call: 0x401462 with key: 164047060 and buffer: 0x40f040
Result: POST
String decoder call: 0x401d5c with key: 2119968707 and buffer: 0x40f090
Result: WinSta0\Default
```

We now have to make some small tweaks on this script to label each one of the resolved strings and we are good to go:
```
Up	p	sub_4010DC+14	call    func_string_decode; %s:Zone.Identifier
Up	p	sub_40140A+58	call    func_string_decode; POST
Up	p	sub_401D2B+31	call    func_string_decode; WinSta0\Default
Up	p	sub_406104+7A	call    func_string_decode; %u.%u.%u.%u
Up	p	sub_406104+7A	call    func_string_decode; %u.%u.%u.%u
[...]
Up	p	sub_40A457+14	call    func_string_decode; Global\I%X
Up	p	sub_40A4B0+14	call    func_string_decode; Global\M%X
Up	p	sub_40CD9E+35	call    func_string_decode; %s\%s.exe
[...]
```

This IDAPython script is available in this repository.

We have made our life a bit easier, and we can now make some assumptions on this payload's behaviour.

Let's go further and try to beat this API hashing technique that prevents us to understand what this sample's doing.

# API Hashing
======================================

Now that we have some decipher strings, we can spot the API hashing routine by following where the plaintext DLL name are used.

They can be reconized as a big array of hashs is created + the fact that a precise library is loaded right after:
```C
[...]
api_hash_array[368] = 1047881021;
api_hash_array[369] = 0x63745070;
api_hash_array[370] = 0x26CAC314;
api_hash_array[371] = 0x89B9E91F;
[...]
decoded_advapi32_dll = func_string_decode(dword_40F800, 2097492036);
handler_advapi32 = (int)LoadLibraryW(decoded_advapi32_dll);
[...]
return func_api_hashing_wrapper((int)api_hash_array, handler_advapi32, 372, 0x592F308A, (int)&unk_40FF10);
```

Following this function lead to a simple wrapper:
```C
if ( dll_handler )
    result = func_api_hashing(hash_array, dll_handler, num_1, hash_1, buffer);
else
    result = 0;
return result;
```

The API hashing core function starts by navigating through the laoded DLL header to grab some of it's importants values:
```C
[...]
imageNTHeader = dll_handler + *(_DWORD *)(dll_handler + 0x3C);
RVA_export_table = (char *)(dll_handler + *(_DWORD *)(imageNTHeader + 0x78));
RVA_addressOfFunctions = dll_handler + *((_DWORD *)RVA_export_table + 7);
RVA_addressOfNames = dll_handler + *((_DWORD *)RVA_export_table + 8);
RVA_addressOfNamesOrdinal = dll_handler + *((_DWORD *)RVA_export_table + 9);
[...]
```

The value corresponding to each offsets can be retreive from the `IMAGE_EXPORT_DIRECTORY` structure:
```
public struct IMAGE_EXPORT_DIRECTORY
    {
        public UInt32 Characteristics;
        public UInt32 TimeDateStamp;
        public UInt16 MajorVersion;
        public UInt16 MinorVersion;
        public UInt32 Name;
        public UInt32 Base;
        public UInt32 NumberOfFunctions;
        public UInt32 NumberOfNames;
        public UInt32 AddressOfFunctions;    
        public UInt32 AddressOfNames;     
        public UInt32 AddressOfNameOrdinals;  
    }
```

Whith thoses, the function is able to parse each exported function of the target DLL.

Next, a loop is initialized, and a hash is produced for each function name in the export table directory:
```C
for ( i = 0; i < *((_DWORD *)RVA_export_table + 6); ++i )// RVA_export_table + 6 = RVA_numberOfFunctions
{
    api_hash = hash_1 ^ func_create_sub_hash((_BYTE *)(dll_handler + *(_DWORD *)(RVA_addressOfNames + 4 * i)));// RVA_addressOfNames + 4 = RVA_Name
    resolved_row = 0;
    if ( arg_number_of_entry )
    {
      	while ( *(_DWORD *)(hash_array + 4 * resolved_row) != api_hash )
      	{
        	if ( ++resolved_row >= arg_number_of_entry )
	        	goto HASH_FAILED;
      	}
    [...]
```

We can observe that this hash is a combination of the `func_create_sub_hash` and a XOR operation with a given argument.

Thanksfully, this function is easy to understand:
```C
result = 0;
while ( *RVA_addressOfName )
    result = (char)*RVA_addressOfName++ + 0x1003F * result;
return result;
```

We can implement this hashing routine in python that way:
```python
key = 0x592F308A

for name in api:
    result = 0
    for char in name:
        result  = (result * 0x1003f) & 0xffffffff
        result =  (result + ord(char)) & 0xffffffff

    api_hash = result ^ key
    print('%s : 0x%08X' % (name, api_hash))
```

The tricks here is to keep every operation reuslt as a DWORD.

Since we are targeting `advapi32.dll`, let's grab a list of it's exported function, add geenrate a list of corresponding hashes:
```
[...]
RegSaveKeyExA : 0xDE74FD8A
RegSaveKeyExW : 0xDE74FD9C
RegSaveKeyW : 0xF9DCAA43
RegSetKeySecurity : 0x61DCCC3B
RegSetKeyValueA : 0x86D4C04B
RegSetKeyValueW : 0x86D4C05D
RegSetValueA : 0xBD07C334
RegSetValueExA : 0x01F06001
RegSetValueExW : 0x01F0602B
RegSetValueW : 0xBD07C35E
RegUnLoadKeyA : 0xCFA4B93F
RegUnLoadKeyW : 0xCFA4B941
RegisterEventSourceA : 0xA8137B45
RegisterEventSourceW : 0xA8137B6F
[...]
```

This is working !

For today, I'll just confirm that the algorithm is fine, and I'll came back latter to automate the API resolution in IDA.

Taking random values from the API hash array shows us that we indeed have a way to recover the imported API:
```
[root@Arch emotet]# cat /tmp/api | grep 74620926
ChangeServiceConfig2W : 0X74620926
[root@Arch emotet]# cat /tmp/api | grep 9A13D723
GetServiceDisplayNameW : 0X9A13D723
```

I almost had a heart attack, since the majority of the entry in the API array does not resolve _on purpose_, just to fuck with us ...

Anyway, we have beaten this API hashing technique, wich is a pretty common one :)
