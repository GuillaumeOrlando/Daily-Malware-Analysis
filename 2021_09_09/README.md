# Emotet Loader

MD5: 36bedd423ba81c251be1027f6ac079e4

OriginalFileName: Ale7g_8.exe

Size: 356 KB

========================================

Seems to be from the April 2019 campaigns

Extremely high entropy for the section .rsrc (almost at 8).

By taking a look at the resources with `Resource Hacker` we can spot a suspicious "RCData" resource that contain some unreadable bytes.
```
7A EB 05 BA 60 80 D6 F0 E6 A5 D3 B3 62 E1 13 8A 
41 29 76 E7 5A 2E BA 10 CA 46 9F E1 96 DC 67 FA 
54 DB E8 3B 73 D8 47 B3 83 6A 4D 8F BE 25 83 81 
06 29 03 F9 96 E8 4D 64 48 E8 54 04 F5 D4 47 C9 
[...]
BE 17 1F C1 D3 97 B4 40 DC 21 C5 87 5F 05 89 86 
D1 2A 56 6C 7E D3 6F F1 6E 20 72 1F C9 C6 FC FC 
AE B0 43 
```

Some GUI resources have also been added in the binary, maybe to blur the presence of this buffer in it ...

If we observe the binary in IDA, we can see that some undocumented functions like `LdrFindResource_U` or `LdrAccessResource` are used to remains stealthy during runtime.
```C
LdrAccessResource = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))GetProcAddress(hModule, aLdraccessresou);
[...]
LdrAccessResource(0x400000, v35, &Src, &dwSize);
```

The string of those API are pushed on the stack using some shady techniques to makes it less obvious.
```
mov     esi, offset Str ; "LdrFin"
push    esi             ; Str
[...]
mov     esi, offset aDreso ; "dReso"
push    esi             ; Str
[...]
mov     esi, offset aUrceU ; "urce_U"
push    esi             ; Str
[...]
mov     esi, offset aAcces ; "Acces"
push    esi             ; Str
[...]
mov     esi, offset aSresource ; "sResource"
push    esi             ; Str
[...]

```

The overall execution can be resumed in these few lines of pseudo-code:
```C
LdrAccessResource = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))GetProcAddress(hModule, aLdraccessresou); // Resorve the API used to laod the resource
if ( LdrFindResource_U(0x400000, v34, 3, &v35) >= 0 )		// Load the target resource
    LdrAccessResource(0x400000, v35, &Src, &dwSize);		
ptr_alloc_buffer = VirtualAlloc(0, dwSize, 0x1000u, 0x40u);	// Make room for the resource
memcpy(ptr_alloc_buffer, Src, dwSize);				// Copy the resource contents in mmeory
sub_4010B4(var_maybe_key, 0x54, (int)var_probably_key); 	// Do something with what's looks like a key
sub_401163(ptr_alloc_buffer, dwSize, var_probably_key); 	// Do something with the resource in memory and the key
((void (*)(void))ptr_alloc_buffer)();                   	// Execute the memory segment
```

What we assume is a decryption key hold the value: `"bTBpgJl63mRyyty*%JLPY(vwzW!tqcHfagqA$@c2FSGo#gE5i<IBNqFEf2P$mpn<Z"`

Let's confirm our theory through a debuger and see what's happening in the resource.

We want to monitor the buffer beeing allocated through the `VirtualAlloc()` call.
```
00407DDB | 57                       | push edi                                                       |
00407DDC | FF15 84E4C100            | call dword ptr ds:[<&VirtualAlloc>]                            |
00407DE2 | FF75 FC                  | push dword ptr ss:[ebp-4]                                      |
```

```
02A40000  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................  
02A40010  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................  
02A40020  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................  
02A40030  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................  
```

As suspected, the `memcpy()` call copy the resource in this specific buffer.

```
00407DEA | 56                       | push esi                                                       |
00407DEB | E8 D0230000              | call <JMP.&memcpy>                                             |
00407DF0 | 8D45 FA                  | lea eax,dword ptr ss:[ebp-6]                                   |
00407DF3 | 50                       | push eax                                                       |
```

```
02A40000  7A EB 05 BA 60 80 D6 F0 E6 A5 D3 B3 62 E1 13 8A  zë.º`.Öðæ¥Ó³bá..  
02A40010  41 29 76 E7 5A 2E BA 10 CA 46 9F E1 96 DC 67 FA  A)vçZ.º.ÊF.á.Ügú  
02A40020  54 DB E8 3B 73 D8 47 B3 83 6A 4D 8F BE 25 83 81  TÛè;sØG³.jM.¾%..  
02A40030  06 29 03 F9 96 E8 4D 64 48 E8 54 04 F5 D4 47 C9  .).ù.èMdHèT.õÔGÉ  
```

The function sub_401163() is indeed in charge of decrypting this buffer with the given key.

```
00407E03 | 50                       | push eax                                                       |
00407E04 | FF75 FC                  | push dword ptr ss:[ebp-4]                                      |
00407E07 | 56                       | push esi                                                       |
00407E08 | E8 5693FFFF              | call ale7g_8 - copy.401163                                     | decode shellcode 1
00407E0D | 83C4 24                  | add esp,24                                                     |
```

```
02A40000  E8 00 00 00 00 58 89 C3 05 29 05 00 00 81 C3 29  è....X.Ã.)....Ã)  
02A40010  0F 03 00 68 01 00 00 00 68 05 00 00 00 53 68 80  ...h....h....Sh.  
02A40020  7B 1C ED 50 E8 04 00 00 00 83 C4 14 C3 83 EC 48  {.íPè.....Ä.Ã.ìH  
02A40030  83 64 24 18 00 B9 4C 77 26 07 53 55 56 57 33 F6  .d$..¹Lw&.SUVW3ö  
```

The execution flow is then passed to this decrypted buffer:
```
00407E10 | FFD6                     | call esi                                                       | jump to shellcode 1
```

Let's go further with our dynamic analysis, and try to intercept the next stage directelly.

A breakpoint can be placed on `CreateProcessInternalW()`, `WinExec()` and `CreateFileA()`, just in case.

Unfortunatelly, the process crash shortely after entering the loaded shellcode.

Some sort of anti-analysis techniques must be used in it, as nothing stand off from the original binary.

If we take a closer look at what we have dumped, the start is indeed a shellcode, but we can spot a PE header a bit further down.
```
02A80500  D2 0F 85 6B FF FF FF 33 C0 5F 5E 5D 5B 83 C4 10  Ò..kÿÿÿ3À_^][.Ä.  
02A80510  C3 8B 74 24 10 8B 44 16 24 8D 04 58 0F B7 0C 10  Ã.t$..D.$..X.·..  
02A80520  8B 44 16 1C 8D 04 88 8B 04 10 03 C2 EB DB 4D 5A  .D.........ÂëÛMZ  
02A80530  90 00 03 00 00 00 04 00 00 00 FF FF 00 00 B8 00  ..........ÿÿ..¸.  
02A80540  00 00 00 00 00 00 40 00 00 00 00 00 00 00 00 00  ......@.........  
02A80550  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................  
02A80560  00 00 00 00 00 00 00 00 00 00 C8 00 00 00 0E 1F  ..........È.....  
02A80570  BA 0E 00 B4 09 CD 21 B8 01 4C CD 21 54 68 69 73  º..´.Í!¸.LÍ!This  
02A80580  20 70 72 6F 67 72 61 6D 20 63 61 6E 6E 6F 74 20   program cannot   
02A80590  62 65 20 72 75 6E 20 69 6E 20 44 4F 53 20 6D 6F  be run in DOS mo  
```

Dumping this PE file reveal a new binary (valid one, not mapped in memory, with a limited amount of imports and, once again, a high entropy).

And we now have the next stage used by the loader.


# Emotet Loader - Unpacking

MD5: 3ea356c951de6ddde76263bf353ac8e9

OriginalFileName: N/A

Size: 195 KB

======================================

Once again, this file conatins another embeeded PE file.

For an easier debugging process, this new binary will be launch trough the stage 1, as Emotet is known to do some "complicated" memory manipulation with shared buffer between it's stages.

We don't really care about what the loader is going, since we just want to reach the final payload.

A quick static analysis of the binary show that this stage will allocate some more memory, dynamically resolve some functions, and transfer the execution back to another piece of code. 

This can be observed by placing breakpoints on `VirtualAlloc` and `VirtualProtect`.

The first hit to `VirtualProtect()` reveal a buffer filled with code, ready to be marked as executable (PAGE_EXECUTE_READ).

Taking a look at this buffer reveal that it's content matchs the embedeed hardcoded PE file found in the dumped file.

We can extract it and analyse it.

In order not to miss the next stage of the loader, we'll put some breakpoints on `CreateProcessInternalW`, `WriteProcessMemory`, `NtUnmapViewOfSection`, `ResumeThread` and `ExitProcess`, just in case.

After a few breakpoints hit, a noticable think happend: A buffer is allocated, and a new PE is writen into it, sections by sections.

Just after, it's memory protection are also set to PAGE_EXECUTE_WRITE.

This one is also dumped on disk for a further analysis.

Then, the execution is transfered to this binary.

Shortly after it execution, the content of the original (stage 2) laoder is unmaped from memory (`ZwUnmapViewOfSection`, placing a breakpoint on this wasn't a bad idea after all).

But we don't really care at this point, since we have plenty of dump to deal with.

The execution can be stoped.

The one extract that gain my attention is the one with an incomplete header (second dump).
```
02AC00B0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................  
02AC00C0  00 00 00 00 00 00 00 00 50 45 00 00 4C 01 04 00  ........PE..L...  
02AC00D0  76 07 9C 5F 00 00 00 00 00 00 00 00 E0 00 02 21  v.._........à..!  
02AC00E0  0B 01 0C 00 00 1A 00 00 00 EC 02 00 00 00 00 00  .........ì......  
02AC00F0  B0 27 00 00 00 10 00 00 00 30 00 00 00 00 00 10  °'.......0......  
[...]
02AC01C0  2E 74 65 78 74 00 00 00 0C 18 00 00 00 10 00 00  .text...........  
02AC01D0  00 1A 00 00 00 04 00 00 00 00 00 00 00 00 00 00  ................  
02AC01E0  00 00 00 00 20 00 00 60 2E 72 64 61 74 61 00 00  .... ..`.rdata..  
02AC01F0  50 02 00 00 00 30 00 00 00 04 00 00 00 1E 00 00  P....0..........  
02AC0200  00 00 00 00 00 00 00 00 00 00 00 00 40 00 00 40  ............@..@  
02AC0210  2E 64 61 74 61 00 00 00 70 E4 02 00 00 40 00 00  .data...pä...@..  
```

In order to fix it, we first have to add a new header to the file (simply copy the one from the original bainry).

Then, we need to 'unmap' it by fixing it's section header's. The goal is to make the 'Raw Addr.' match the 'Virtual Addr.' and to calculate the corresponding 'Raw size' and 'Virtual Size'. After that, the 'Image base' field of the Optional header can be fixed with the dumped address.
```
	Raw Addr.	Raw Size	Virt Addr.	Virt. Size
.text	1000		2000		1000		2000
.rdata	3000		1000		3000		1000
.data	4000		2F000		4000		2F000
.reloc	33000		200		33000		88
```

To finish this, the start of the pe data need to be placed at the address of the virtale address of the first section that we've fixed.

That way, everything is properly aligned.

To confirm that our dump is a valid one, PE-Bear shows us some entry in the IAT that looks valid !
```
KERNEL32.dll
	VirtualFree
	Process32First
	Process32Next
	CreateToolhelp32Snapshot
	[...]
NTDLL.dll
	bsearch
	wcslen
	[...]
```

We now have the final Emotet payload, ready to be analysed :)
